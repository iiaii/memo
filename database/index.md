# 인덱스

## 쿼리 실행 순서 (선행 지식)

1. From 과 Join

데이터 셋의 총양을 결정하기 위해 From, Join 이 먼저 실행된다. (서브쿼리 포함, 서브쿼리 실행시 모든 행과 열을 포함하는 임시 테이블이 생성될 수 있음)

1. Where

데이터 셋의 총양을 구한 뒤, 제약조건인 Where 절이 각 행(row)에 적용되어 조건을 충족하지 않은 행을 제거한다. (Where 절에서는 Alias를 적용할 경우 대부분의 데이터베이스에서 오류가 발생한다)

1. Group by

Where 절이 적용된 뒤 남은 행들은 이후 Group by 절에 의해 그룹으로 묶인다

1. Having

쿼리에 Group by 절이 있다면 그룹으로 묶인 행에 제약조건인 Having 절이 각 행에 적용되어 조건을 충족하지 않은 행을 제거한다. (Where 절과 마찬가지로 Alias를 적용할 경우 대부분의 데이터베이스에서 오류 발생)

1. Select

1. Distinct

남아있는 행중 중복되는 행이 제거된다.

1. Order by

 

Order by 절에 의해 행들은 특정 규칙에 맞게 오름차순 혹은 내림차순으로 정렬된다. (Alias 적용해도 정상 작동)

1. limit / offset 

limit offset 에 의해 지정된 범위를 벗어나는 행이 제거됨 

## 인덱스란?

인덱스는 지정한 컬럼들을 기준으로 메모리 영역에 목차를 생성하는 것이다. 생성, 변경, 삭제의 명령을 희생하고 조회의 성능을 향상시키게된다. 변경과 삭제를 하기위해 데이터를 조회하는것 자체는 인덱스가 있으면 빠르게 조회가 된다. 그래서 변경이나 삭제해야할 데이터가 많은 경우 인덱스로 지정된 컬럼을 기준으로 진행하는것이 좋다. (많은 데이터를 변경, 삭제하는 경우 인덱스 컬럼이 아니면 상당히 느려질 수 있음)

### 인덱스의 특징

- 인덱스 구조는 B-Tree (Blanced Tree)로 구성되어있다.
- 탐색은 Root → Branch → Leaf → 디스크 저장소 순으로 진행된다
- 인덱스가 여러 컬럼으로 구성되었다면 두번째 컬럼은 첫번째, 세번째 컬럼은 두번째에 의존해서 정렬되어 있다
- 디스크는 메모리에 비해 매우 느리다
- 인덱스 갯수는 3~4개 정도가 적당하다 (너무 많은 인덱스는 Row를 추가하거나 변경할때마다 인덱스를 추가, 수정해야한다. 또한 옵티마이저가 잘못된 인덱스를 선택할 확률도 높아진다)
- 인덱스는 메모리의 페이지 단위로 관리된다 (페이지는 16KB로 고정)
    - 설정한 인덱스 키의 크기와 주소가 담긴 크기에 따라 한 페이지로 조회할 수있는 row의 수가 달라진다 (인덱스 키가 길수록 성능상 이슈가 있다 → 더 많은 페이지를 읽어야함)
- 인덱스는 카디널리티가 가장 높은 컬럼 부터 잡아야 한다 (여러 컬럼을 선정할때도 가장 중복되지 않는 컬럼부터)
- 인덱스의 구조적인 문제 때문에 설정한 첫번째 컬럼이 반드시 조건에 포함되어야 인덱스를 태울수 있다 (나머지 컬럼은 옵션)

> 인덱스가 Hash 나 배열, RedBlack-Tree가 아닌 B-Tree를 사용하는 이유는 범위검색과 삽입, 삭제시 유리하기 때문이다. Hash는 O(1)을 기대할 수 있지만 데이터베이스 검색에서는 = 뿐만 아니라 >, < 와 같은 범위검색을 제공해야한다. B-Tree 를 사용하면 탐색시간 O(logN)으로 Hash 보다는 느리지만 범위검색이 가능하다. 트리를 사용해야 하는것이라면 데이터 접근이 가장 빠른 배열을 사용해도되지만 배열은 데이터를 중간에 삽입하거나 삭제할때 재정렬 과정에서 O(N)이 걸린다. 하지만 B-Tree의 경우 데이터 삽입, 삭제시 O(logN) 보다 작은 O(h) (트리 높이에 따른 시간복잡도를 가지게 된다. 균형트리 중에서 RedBlack-Tree 는 노드가 참조값은 가지는 하나의 노드인것에 반해 B-Tree는 노드가 배열로 구성되어 같은 노드의 데이터는 메모리 공간에 순차적으로 빠르게 접근할 수 있는 이점이 있다. 이론적으로 두 트리는 시간복잡도가 같지만 데이터가 많아질 수록 조금이라도 참조값을 찾는 시간이 적은 B-Tree가 더 빨라지게된다. (B-Tree 노드의 배열 길이는 보통 3~5개정도로 상수 탐색시간으로 제한하고 있다)
>

  
### 인덱스 주의사항

- between, like, <, > 등의 범위 조건은 해당 컬럼까지는 인덱스를 타고 그 뒤의 인덱스 컬럼은 인덱스가 사용되지 않는다 (where group_no=XX and from_date > YY and is_bonus=ZZ 의 경우 is_bonus는 인덱스가 사용되지 않는다)
- =, in은 다음 인덱스 컬럼도 인덱스를 사용한다 (in은 =을 여러번 실행시킨것과 같음)
    - in의 인자값으로 상수가 포함되면 문제없지만 서브쿼리가 오면 서브쿼리 외부가 먼저 실행되고 in 은 체크조건으로 실행되어 성능 이슈가 발생한다
- and 연산자는 각 조건들이 읽어와야할 row 수를 줄이지만 or는 비교해야할 row가 늘어나 풀 테이블 스캔이 발생할 수도 있다
- 인덱스로 사용된 컬럼값 그대로 사용해야 인덱스가 사용된다 (where salary * 10 > 150000 → 인덱스 사용 안됨)
- null 값의 경우 is null 조건으로 인덱스 범위 스캔 가능
- 인덱스 순서와 조건에서의 순서를 지킬 필요는 없다 (MySQL 엔진의 옵티마이저가 인덱스 컬럼 순서에 맞춰 재배열하기 때문, 맞춘다면 재배열 과정이 생략될수도?)
  
  
## 인덱스 컨디션 푸시다운

MySQL 5.6 버전 부터 기본 제공되는 기능으로 인덱스 범위 조건에 사용될 수 없어도 인덱스에 포함된 필드라면 인덱스 조건을 스토리지 엔진으로 넘겨 최대한 스토리지 엔진에서 걸러낸 데이터만 MySQL 엔진에 전달되도록 개선된 방식이다.

인덱스 조건을 스토리지 엔진으로 넘겨주기 때문에 인덱스 컨디션 푸시 다운이라는 이름이 되었다.

MySQL의 쿼리 실행 구조는 MySQL 엔진과 그 뒤에 스토리지 엔진(InnoDB) 로 나누어져 있다.

스토리지 엔진이 넘겨준 데이터 중에서 MySQL 엔진이 한번더 필터링하는 방식이고 MySQL에서 필터링 되는 경우 explain(실행계획)을 확인해보면 Extra: Using where 로 확인된다.

- MySQL 엔진 : 스토리지 엔진에서 받은 데이터를 가공/연산 수행
- 스토리지 엔진 : 디스크나 메모리에서 필요한 데이터를 읽거나 저장

```sql
-- 인덱스 설정
ALTER TABLE temp_ad_offset ADD INDEX idx_temp_ad_offset_2 (customer_id, offset_type);

-- 쿼리
select *
from temp_ad_offset
where customer_id = 7 and offset_type like '%LIST';
```

위 쿼리에서 %로 시작하는 like 조건은 인덱스 범위조건으로 사용할수 없어 인덱스가 적용되지 않는다. MySQL 5.5 까지는 인덱스가 적용되지 않는 조건은 스토리지 엔진으로 넘기지 않는다. 따라서 customer_id 가 7인 데이터까지는 인덱스를 통해 테이블에서 행을 찾아 MySQL 엔진으로 반환하고 MySQL 엔진에서 like 조건이 필터링 처리되어 버려지게된다. (읽지 않아도 될 데이터까지 읽어서 전달)

하지만 5.6 버전부터는 Index Condition Pushdown(ICP)가 기본적으로 지원되어 인덱스에 포함된 필드라면 범위 조건 사용 가능 여부와 상관없이 MySQL 엔진에서 스토리지 엔진으로 전달이 가능하다. 스토리지 엔진은 이전과는 다르게 인덱스에 포함되는 다른 조건까지 전달 받는다. 따라서 스토리지 엔진에서 customer_id 가 7인 모든 행을 읽기전 뒤이은 like 조건을 확인하여 전체 행 읽는것을 방지하게 된다. (시스템 변수로 비활성화 가능 `SET optimizer_switch = 'index_condition_pushdown=off';`)
  
  
  
## 커버링 인덱스

커버링 인덱스는 인덱스 자체에 쿼리에 필요한 모든 컬럼을 가지고 있어 디스크(데이터 블록)까지 접근하지 않고 인덱스 조회만으로 쿼리가 커버되는 인덱스를 말한다. 

- 커버링 인덱스가 적용되면 Explain 에서 `Extra: Using index` 로 표기된다
    - Extra: Using index → 커버링 인덱스
    - Extra: Using index condition → 인덱스 컨디션 푸시다운
    
  
  
  
## 1. 페이징 성능 개선 - No Offset (더보기, 숫자 없는 페이징)

페이징 처리에서 숫자 방식이 아닌 더보기 버튼으로 확장되는 방식이라면 No Offset 방식을 통해 개선이 가능하다.

기본적으로 limit, offset 을 사용하면 페이징이 뒤로 갈수록 느려진다. 왜냐하면 limit, offset 은 쿼리 실행시 제일 마지막에 실행되기 때문에 그 앞의 select 하는 과정에서 모든 필드를 조회한다면 실제 디스크에 접근(데이터 블록을 조회) 하는 일이 발생하게 된다. 페이지의 앞쪽이라면 큰 지연이 발생하지 않지만 뒤로갈수록 앞에서 읽었던 행을 누적해서 계속 읽기 때문에 점점 속도가 저하되게 된다. (offset 100000, limit 20 이면 100020 개의 행을 읽고 앞의 100000개 행을 버리게 된다 - 쿼리 실행 순서에 의함)

No Offset 방식은 조회 시작 부분을 인덱스로 찾아 첫 페이지부터 읽도록 하는 방식이다.

```sql
SELECT *
FROM items
WHERE 조건문
AND id < 마지막조회ID # 직전 조회 결과의 마지막 id
ORDER BY id DESC
LIMIT 페이지사이즈
```

우선 마지막 조회한 id를 기억하거나 클라이언트로 부터 입력받도록 한다. 입력받은 id(pk)는 where 절에서 사용하기 때문에 PK로 구성된 클러스터 인덱스를 타게된다. 이 쿼리는 페이지가 뒤로 가는 것과는 무관하게 마지막 idx를 조회시 사용하기 때문에 인덱스를 타서 빠르고 일관된 성능을 가지게 된다.

- 단점
    - group by 등을 사용하면서 기준으로 잡는 키가 중복되는 경우 정확한 결과 반환이 어렵다 (Group by는 집계 키 기준으로 집합 연산을 위해 사용. 집합연산 - count, sum, avg, max, min)
    - UX/UI 관점에서 더보기 버튼이 가능한 경우만 가능
  
  
  
## 2. 페이징 성능 개선 - 커버링 인덱스

```sql
-- 다음의 쿼리를 ()

SELECT *
FROM items
WHERE 조건문
ORDER BY id DESC
OFFSET 페이지번호
LIMIT 페이지사이즈

-- 아래와 같이 개선 (서브 쿼리에서 커버링 인덱스 사용)

SELECT  *
FROM  items as i
JOIN (SELECT id
        FROM items
        WHERE 조건문
        ORDER BY id DESC
        OFFSET 페이지번호
        LIMIT 페이지사이즈) as temp on temp.id = i.id
```

일반적으로 사용하는 첫번째 쿼리는 인덱스를 타더라도 select 하는 일부 항목들은 인덱스에 없기 때문에 order by, offset ~ limit 을 수행시 매번 데이터 블록에 접근하게 된다. (limit 과 offset이 뒤쪽이면 뒤쪽까지 순회를 해야해서 느려질 수 밖에 없다)

- 메모리의 데이터 단위 - 페이지 (16KB)
- 디스크의 데이터 단위 - (데이터) 블록 (4~16KB)

커버링 인덱스 방식을 사용하면 서브쿼리에서 커버링 인덱스를 사용하여 빠르게 처리하고 걸러진 데이터를 통해 실제 반환할 데이터를 가져올때만 데이터 블록에 접근하기 때문에 훨씬 빠르게 처리된다. (pk는 별다른 세팅을 하지 않으면 자동으로 클러스터 인덱스로 설정된다) → 서브쿼리를 먼저 실행한다기보다 쿼리 실행 순서를 보면 From 과 Join 이 먼저 실행되기 때문에 서브쿼리를 통해 커버링 인덱스를 먼저 타게 된다.
  
  
  
## 3-1. 페이징 성능 개선 - 페이지 건수 고정 (페이지 지연 로딩)

특정 상수로 고정된 페이지 수를 제공하다가 페이지 버튼을 눌렀을때 실제 데이터 수가 페이지의 양보다 적으면 그때 페이지 로딩 혹은 페이지 버튼을 누르면 그때 페이지 지연로딩하는 방법

실제로 페이지 버튼을 클릭하는 경우는 20% 이하이기 때문에 UX/UI 적으로 문제가 되지 않으면 사용할 수 있음
  
  
  
## 3-2. 페이징 성능 개선 - 첫 페이지 조회 결과 cache

첫 검색에서 조회된 count 결과를 응답으로 내려주고 매 페이징 버튼마다 처음에 조회한 count 결과를 함께 내려준다. (프론트 영역에서 요청시에 전체 count를 함께 보내주는 구조)

- 단점
    - 첫 페이지 조회가 대부분인 경우 개선되는 것이 없다
    - 실시간으로 데이터 수정이 필요해 버튼 반영이 필요한 경우 사용이 불가능하다


---
- https://jojoldu.tistory.com/529?category=637935
- https://jaimemin.tistory.com/1475
- https://steady-coding.tistory.com/558
- https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html
