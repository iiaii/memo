# 시스템 구조와 프로그램 실행

![computer system](https://github.com/iiaii/memo/blob/master/images/computerSystem.png?raw=true)

- CPU는 매 클럭 마다 메모리에 있는 다음 인스트럭션을 실행하기만 한다 (한 인스트럭션이 끝나면 Interrupt line을 체크)
- CPU에는 메모리다 빠른 레지스터가 있음 
- 작업 수행중에 디스크에서 뭔가 읽어오는 작업이나 키보드 입력 작업은 인터럽트를 발생시키고 디바이스 컨트롤러가 요청해서 인스트럭션이 메모리에 탑재된다
- 디바이스 컨트롤러에도 레지스터와 버퍼가 있고 수행된 결과를 반영하는 디바이스 제어 작업을 담당한다
- 디바이스 컨트롤러에 펌웨어가 있어서 디바이스를 제어하기 위한 코드들이 따로 존재한다
- 타이머는 한 프로그램이 독점적으로 사용하지 못하도록 세팅된 시간만큼 실행되면 인터럽트를 건다 
  (사용자 프로그램의 CPU 제어권이 OS로 넘어감 -> 줄때는 자유롭게 주지만 뺐지는 못해서 타이머를 통해 인터럽트가 발생하도록 함)
- 타임쉐어링이 구현될 수 있도록 타이머가 존재함 (인터럽트가 발생하면 CPU 제어권이 OS로 넘어감)
- 사용자 프로그램은 IO 장치에 접근할 수 없고 운영체제만이 할 수 있음
- mode bit은 CPU 제어권이 운영체제인지 사용자 프로그램인지 구분하고 사용자 프로그램의 잘못된 수행으로 부터 보호하기 위해 존재한다
- mode bit이 0일때는 운영체제가 CPU 제어권을 가지고 있기 때문에 모든 인스트럭션이 가능 (IO 포함), 사용자 프로그램이 실행될때는 mode bit이 1로 변경됨 (한정된 인스트럭션만 실행 가능)
- DMA Controller는 중간중간 들어오는 IO 작업을 메모리에 적재하고 CPU에게 메모리에 적재했다는 인터럽트를 발생시킨다 (CPU에게 직접적인 인터럽트를 주어 잦은 컨텍스트 스위칭을 방지하기 위함)
- Memory Controller는 CPU와 DMA Controller가 메모리에 동시 접근함으로 발생하는 오류를 방지해주는 역할을 한다
- 사용자 프로그램은 운영체제를 통해서만 IO를 한다 -> 사용자 프로그램은 운영체제가 필요할때 CPU 인터럽트를 발생시켜서 제어권을 반납하고 OS에게 요청한다 (시스템 콜) -> OS도 올바른 요청인지 확인후 수행
(사용자 프로그램이 IO를 하기위해 2가지 인터럽트가 발생한다 > IO요청할때 발생하는 소프트웨어 인터럽트, IO 끝났을때 발생하는 것은 하드웨어 인터럽트)

> CPU는 숙명은 PC(프로그램 카운터)에 있는 다음 인스트럭션 주소를 실행하는 것이다 

-> 현대의 운영체제는 인터럽트에 의해 구동된다
-> 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널함수를 호출하는 것을 시스템 콜이라고 한다
-> 인터럽트 벡터라고 불리는 인터럽트 처리 루틴 주소를 가지고 있다




