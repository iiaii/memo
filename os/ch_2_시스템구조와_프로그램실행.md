# 시스템 구조와 프로그램 실행

![computer system](https://github.com/iiaii/memo/blob/master/images/computerSystem.png?raw=true)

- CPU는 매 클럭 마다 메모리에 있는 다음 인스트럭션을 실행하기만 한다 (한 인스트럭션이 끝나면 Interrupt line을 체크)
- CPU에는 메모리다 빠른 레지스터가 있음 
- 작업 수행중에 디스크에서 뭔가 읽어오는 작업이나 키보드 입력 작업은 인터럽트를 발생시키고 디바이스 컨트롤러가 요청해서 인스트럭션이 메모리에 탑재된다
- 디바이스 컨트롤러에도 레지스터와 버퍼가 있고 수행된 결과를 반영하는 디바이스 제어 작업을 담당한다
- 디바이스 컨트롤러에 펌웨어가 있어서 디바이스를 제어하기 위한 코드들이 따로 존재한다
- 타이머는 한 프로그램이 독점적으로 사용하지 못하도록 세팅된 시간만큼 실행되면 인터럽트를 건다 
  (사용자 프로그램의 CPU 제어권이 OS로 넘어감 -> 줄때는 자유롭게 주지만 뺐지는 못해서 타이머를 통해 인터럽트가 발생하도록 함)
- 타임쉐어링이 구현될 수 있도록 타이머가 존재함 (인터럽트가 발생하면 CPU 제어권이 OS로 넘어감)
- 사용자 프로그램은 IO 장치에 접근할 수 없고 운영체제만이 할 수 있음
- mode bit은 CPU 제어권이 운영체제인지 사용자 프로그램인지 구분하고 사용자 프로그램의 잘못된 수행으로 부터 보호하기 위해 존재한다
- mode bit이 0일때는 운영체제가 CPU 제어권을 가지고 있기 때문에 모든 인스트럭션이 가능 (IO 포함), 사용자 프로그램이 실행될때는 mode bit이 1로 변경됨 (한정된 인스트럭션만 실행 가능)
- DMA Controller는 중간중간 들어오는 IO 작업을 메모리에 적재하고 CPU에게 메모리에 적재했다는 인터럽트를 발생시킨다 (CPU에게 직접적인 인터럽트를 주어 잦은 컨텍스트 스위칭을 방지하기 위함)
- Memory Controller는 CPU와 DMA Controller가 메모리에 동시 접근함으로 발생하는 오류를 방지해주는 역할을 한다
- 사용자 프로그램은 운영체제를 통해서만 IO를 한다 -> 사용자 프로그램은 운영체제가 필요할때 CPU 인터럽트를 발생시켜서 제어권을 반납하고 OS에게 요청한다 (시스템 콜) -> OS도 올바른 요청인지 확인후 수행
(사용자 프로그램이 IO를 하기위해 2가지 인터럽트가 발생한다 > IO요청할때 발생하는 소프트웨어 인터럽트, IO 끝났을때 발생하는 것은 하드웨어 인터럽트)

> CPU는 숙명은 PC(프로그램 카운터)에 있는 다음 인스트럭션 주소를 실행하는 것이고 인터럽트가 걸리면 OS에게 CPU 제어권이 넘어간다

-> 현대의 운영체제는 인터럽트에 의해 구동된다
-> 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널함수를 호출하는 것을 시스템 콜이라고 한다
-> 인터럽트 벡터라고 불리는 인터럽트 처리 루틴 주소를 가지고 있다
 
---
### 동기식 입출력과 비동기식 입출력

##### 동기식 입출력 

- IO 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
- 구현 방법 1
  - IO가 끝날 때까지 CPU를 낭비시킴
  - 매시점 하나의 IO만 일어날 수 있음
- 구현 방법 2
  - IO가 완료될 때 까지 해당 프로그램에게서 CPU를 빼앗음
  - IO 처리를 기다리는 줄에 그 프로그램을 줄 세움
  - 다른 프로그램에게 CPU를 줌

##### 비동기식 입출력

- IO가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감


> 두 경우 모두 IO의 완료는 인터럽트로 알려줌
 

---
### DMA (Direct Memory Access)

매 IO 마다 인터럽트가 발생하게 되면 CPU가 효율적으로 작동하지 못한다.
따라서 메모리에 접근 가능한 DMA라는 것을 만들어 해결한다. 

IO 작업을 디바이스 컨트롤러 쪽에서 각각 일정 버퍼의 블럭, 페이즈 단위로 쌓이면, DMA는 카피해서 메모리에 적재하고 IO 작업이 있다고 CPU에게 인터럽트를 걸어 알리게 된다.
(인터럽트 빈도가 낮아짐)

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송
- 바이트 단위가 아니라 블럭 단위로 인터럽트를 발생시킴


---
### 저장장치 계층 구조


- Primary - 빠르고 휘발성이고 비쌈, CPU가 바로 실행가능하다 (바로 실행가능하려면 바이트 단위로 접근가능해야함, D램은 가능)
  - Registers (제일 비쌈)
  - Cache Memory
  - Main Memory (요즘은 비휘발성 매체도 가능)
- Secondary - 비휘발성이고 느리고 저렴
  - Magnetic Disk
  - Optical Disk
  - Magnetic Tape


> 상하관계를 가지며 위로갈수록 용량이 적고 비싸고 빠르다. (자주 접근하는것들이 위로 올라오고 안쓰는것은 밑으로 내려감)
 

---
### 프로그램의 실행

![programExecution](https://github.com/iiaii/memo/blob/master/images/programExecution.png?raw=true)

모든 프로그램은 `stack - data - code` 형태의 가상 주소 공간을 가진다.

- OS의 커널의 경우 항상 물리 메로리에 상주해 있는다.
- 프로그램의 가상 주소 공간은 실행될때는 물리 메로리에 위치하고 프로그램이 종료되거나 사용되지 않으면서 보관되어야 할때 Swap area로 이동하게 된다
- Swap area와 File system (비휘발성)의 용도가 다르기 때문에 관리하는 방법도 다르다
- Adress translation은 물리 메모리와 파일시스템으로 부터 넘어오는 프로그램 프로세스의 가상메모리상의 주소가 다른것을 바꿔줌


---
### 커널 주소 공간의 내용

![kernel](https://github.com/iiaii/memo/blob/master/images/kernel.png?raw=true)

- 커널은 프로그램들을 관리하기 위한 PCB 자료구조를 data에 만들어진다.
- 운영체제의 코드는 여러 프로그램들이 시스템콜을 통해 사용하기 때문에 각 프로그램마다 stack에 다른 영역으로 구분되어 쌓인다
- 사용자 정의함수와 라이브러리 함수 모두 각 프로그램의 가상 주소공간의 코드 블럭에 위치하게 되고 커널 함수는 커널 프로그램의 가상 주소 공간의 코드블럭에 별도로 위치한다






