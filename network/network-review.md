# 네트워크 (HTTP, TCP/IP)

### IP 

노드의 주소로서 패킷 단위로 데이터가 전달 됨



##### 한계점

- 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- 비신뢰성 : 패킷이 사라지거나 순서대로 오지 않을 수 있음
- 프로그램 구분 : 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 2가지 이상이면? -> 포트 구분

> TCP, UDP 를 통해 해결


---
### TCP, UDP

애플리케이션 계층 - HTTP, FTP
전송 계층 - TCP, UDP
인터넷 계층 - IP
네트워크 인터페이스 계층


##### IP 패킷 정보

- 출발지 IP
- 목적지 IP
- 기타

##### TCP 세그먼트 정보

- 출발지 port
- 목적지 port
- 전송제어, 순서, 검증 정보 …
- 전송 데이터


##### TCP (전송 제어 프로토콜) 특징

- 연결지향 - TCP 3way handshake (가상 연결)
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜
- 현재는 대부분 TCP 사용


##### TCP 3 way handshake

1. SYN: 접속 요청
2. SYN + ACK: 요청 수락
3. ACK와 함께 데이터 전송 가능

> 물리적인 연결이 아닌 가상 연결


##### 순서 보장

TCP 세그먼트 정보에서 전송 제어, 순서 정보를 포함하기 때문에 가능


##### UDP (사용자 데이터그램 프로토콜) 특징

- 하얀 도화지에 비유 (기능이 거의 없음)
- 연결지향 - TCP 3 way handshake X
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름

> IP와 거의 같지만 PORT, 체크섬 정도만 있어서 애플리케이션에서 추가 작업 필요


---
### 포트

같은 IP 내에서 프로세스 구분하는 역할

0 ~ 65535 할당 가능
0~1023 잘 알려진 포트, 사용하지 않는 것이 좋음


---
### DNS


IP는 기억하기 어렵고 변경 될 수 있다..

-> 전화번호부 같은 DNS 사용 



---
### URI 

URI 안에 URL, URN이 있다
-> URI가 가장 큰 개념

- Uniform: 리소스 식별하는 통일된 방식
- Resource: 자원, URI로 식별할 수 있는 모든것 (제한 없음)
- Identifier: 다른 항목과 구분하는데 필요한 정보

##### URL - Locator: 리소스가 있는 *위치*를 지정

`scheme://[userinfo@]host[:port][/path][?query][#fragment]` 
-> `https://www.google.com:443/search?q=hello&hl=ko`


- userinfo는 거의 사용하지 않음
- host는 주소
- port는 보통 생략
- path는 리소스가 있는 경로로서 계층적 구조로 구성
- query는 key=value 형태로 구성 (query = query parameter, query string)
- fragment는 내부 북마크 등에 사용 (서버에 전송하는 정보는 아님)


---
### 웹 브라우저 요청 흐름


1. 웹브라우저에 `https://www.google.com:443/search?q=hello&hl=ko` 입력
2. `www.google.com` DNS 조회, IP와 포트 정보 찾아냄
3. HTTP 요청 메시지 생성

- HTTP 요청 메시지

``` 
GET /search?q=hello&hlko HTTP/1.1
Host: www.google.com
```

4. SOCKET 라이브러리를 통해 전달

[image:40DE24FF-614B-4747-BBFB-4ACFD2689182-88164-0000834E828572F6/스크린샷 2021-03-23 오후 6.03.25.png]

웹 브라우저와 TCP/IP 사이의 소켓 라이브러리를 통해 전달

5. TCP/IP 패킷 생성

[image:22799032-A752-4177-8D5B-8AACCCB8394B-88164-00008377FDF30E6C/스크린샷 2021-03-23 오후 6.06.23.png]
HTTP 메시지 (웹브라우저가 만든 전송 데이터) + (출발지 IP, PORT / 목적지 IP, PORT)

6. 서버로 요청 전송 및 패킷 해석 (각 계층에서 분해)

[image:76AFB1A4-A25B-4A90-8A4B-E1A5DB461C7C-88164-0000837E1853C8CD/스크린샷 2021-03-23 오후 6.06.50.png]

7. 서버에서 요청 응답 (서버도 똑같이 패킷을 생성)

[image:2D72A45D-F26F-4DFB-9258-4B5FA6F7E7AC-88164-000083928EBBE779/스크린샷 2021-03-23 오후 6.08.19.png]

8. 클라이언트에 요청 결과 전송 및 패킷 분해하여 브라우저가 랜더링


---
### 모든 것이 HTTP

하이퍼 텍스트 전송 프로토콜 

HTML, TEXT, 이미지, 음성, 영상, 파일, Json, XML 등
거의 모든 형태의 데이터 전송 가능

서버간 데이터를 주고 받을 때도 대부분 HTTP 사용

> 지금 거의 대부분 HTTP를 사용


##### 역사


- HTTP/0.9 (1991년): GET 메서드만 지원, 헤더 X
- HTTP/1.0 (1996년): 메서드, 헤더 추가
- **HTTP/1.1** (1997년) : 가장 많이 사용하고 중요한 버전
- HTTP/2 (2015년): 성능 개선 (증가하는 중)
- HTTP/3 (진행중): TCP 대신 UDP 사용하여 성능 개선 (증가하는 중)


##### 특징

- 클라이언트 서버 구조
- 무상태 프로토콜 

서버가 상태를 보존하지 않음 

-> 문맥이 없기 때문에 확장성 높음 
-> 어떤 다른 서버도 일처리가 가능하기 때문에 무한 서버 증설 가능, 서버 장애에도 강함
-> 상태를 유지해야하는 경우(로그인) 어쩔수 없이 상태를 유지해야 함 (최소한으로 사용)
-> 클라이언트가 매번, 많은 데이터 전송 필요

- 비연결성

서버는 연결을 유지할 필요가 없기 때문에 최소한의 자원을 사용할 수 있음 
(응답하고 바로 연결을 종료)

-> 서버 자원을 효율적으로 사용할 수 있음
-> 매번 TCP/IP (3 way handshake) 연결을 새로 맺어야함 (지연 시간 추가)
-> 웹 브라우저로 사이트를 요청하면 수 많은 자원이 함께 다운로드 되는데 매번 연결하고 끊으면 비효율적이기 때문에 지속 연결(Persistent Connections)로 문제 해결 (2.0, 3.0에서는 더 개선됨)

- HTTP 메시지

[image:D1EBA69F-5DA1-415A-855B-F71D00B3603E-88164-000086EAE690CA9A/스크린샷 2021-03-23 오후 7.42.17.png]
[image:D992D2B8-8F3C-4368-A8E3-37AEF3070686-88164-000086F88939C4F4/스크린샷 2021-03-23 오후 7.43.15.png]



- 단순함, 확장가능 

---
### HTTP 메서드

- GET : 리소스 조회
- POST :  요청 데이터 처리, 주로 신규 등록, 변경, 프로세스 처리에 사용

(컨트롤 URI라고해서 리소스가 동사로 표현되는 경우도 있음)
`POST /orders/{orderId}/delivery-start`

- PUT : 리소스를 완전히 대체, 해당 리소스가 없으면 생성

POST와 다르게 리소스가 명확함 (POST는 바디로 데이터가 넘어감)

- PATCH : 리소스 부분 변경

PUT이 완전히 대체하기 때문에 부분적인 변경에 PATCH를 사용
하지만 지원이 안되는 경우가 있기 때문에 이런경우는 POST 사용

- DELETE : 리소스 삭제
- … 

##### 멱등

1번 2번 100번 호출 모두 결과가 똑같아야 함 
(중간에 다른 요청으로 인한 변경은 고려하지 않음)

- GET
- PUT
- DELETE
- ~~POST~~ : 멱등하지 않음


##### 캐시 가능

응답 결과 리소스를 캐시해서 사용해도 되는가?

GET, HEAD, POST, PATCH 캐시 가능
-> 실제로는 GET, HEAD 정도만 캐시로 사용


---
### HTTP 메서드 활용

클라이언트에서 서버로 데이터 전송

- 쿼리 파라미터를 통한 데이터 전송
	- GET
	- 주로 정렬 필터 (검색어)

- 메시지 바디를 통한 데이터 전송
	- POST, PUT, PATCH
	- 회원 가입, 상품 주문, 리소스 등록, 리소스 변경


1. 정적 데이터 조회 (추가적인 데이터 필요 없이 리소스 경로만으로 조회 가능)
2. 동적 데이터 조회 (쿼리 파라미터 사용)
3. HTML Form 데이터 전송 (POST 전송) -> 파일도 전송 가능, GET도 가능
4. HTTP API 데이터 전송 -> 모든 메서드 사용 가능 (웹, 앱, 서버 등 대부분에서 사용)


---
### API 설계 예시

- 회원 목록 조회

`GET /users`

- 회원 조회

`GET /users/{id}`

- 회원 추가

`POST /users/{id}`

- 회원 수정 (PATCH, PUT 이 애매할때 사용)

`POST /users/{id}`

- 회원 완전히 대체

`PUT /users/{id}`

- 회원 부분 변경 (개념적으로는 이것을 사용하는것이 바람직함)

`PATCH /users/{id}`

- 회원 삭제

`DELETE /users/{id}`



##### POST로 등록하는 경우 생성된 리소스를 응답으로 넘겨준다

`POST /members` -> 서버가 알아서 만들어주고 관리한다 (리소스를 모름)

`Location: /users/100` 혹은 바디에 넣어서 리소스 정보를 제공해준다

> 컬렉션 방식 (리소스를 서버가 관리하는 방식, **대부분 서버가 사용하는 방식**)

##### PUT으로 등록하는 경우 덮어쓰기 때문에 클라이언트가 리소스 URI를 알고 있어야 한다.

`PUT /files/100` -> 클라이언트가 리소스를 관리하는 형태

> 스토어 방식 (리소스를 클라이언트가 관리)

##### HTML FORM 사용하는 경우 GET, POST 만 사용 가능

수정/삭제를 POST로만 해야 함

컨트롤 URI를 사용해야 함 -> `POST /members/{id}/delete`

실무에서는 컨트롤 URI를 사용할 경우가 생김


##### 참고하면 좋은 URI 설계 개념

- 문서 (document)

	- 단일 개념 (파일 하나, 객체 인스턴스, 데이터베이스 row)
	- ex) /members/100, /files/star.jpg

- 컬렉션 (collection)

	- 서버가 관리하는 리소스 디렉터리
	- 서버가 리소스의 URI를 생성하고 관리
	- ex) /members

- 스토어 (store) - 거의 사용하지 않음

	- 클라이언트가 관리하는 자원 저장소
	- 클라이언트가 리소스의 URI를 알고 관리
	- ex) /files/100

- 컨트롤러 (controller), 컨트롤 URI

- 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
- 동사를 직접 사용
- ex) /mebers/{id}/delete



